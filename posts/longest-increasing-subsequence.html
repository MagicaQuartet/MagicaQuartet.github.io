<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Longest Increasing Subsequence | [WIP] 까막&#39;s TIL</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Longest Increasing Subsequence 주어진 수열에서 가장 긴 증가하는 부분수열의 길이, 혹은 그 부분수열을 찾는 알고리즘">
    <meta property="og:title" content="Longest Increasing Subsequence">
    <meta property="og:description" content="가장 긴 증가하는 부분수열">
    
    <link rel="preload" href="/assets/css/0.styles.290fa8e4.css" as="style"><link rel="preload" href="/assets/js/app.e00fcf70.js" as="script"><link rel="preload" href="/assets/js/3.ebd08407.js" as="script"><link rel="preload" href="/assets/js/2.6d211023.js" as="script"><link rel="preload" href="/assets/js/20.6f566e45.js" as="script"><link rel="prefetch" href="/assets/js/10.1a1f31b8.js"><link rel="prefetch" href="/assets/js/11.c38f3fc0.js"><link rel="prefetch" href="/assets/js/12.f3ad9f88.js"><link rel="prefetch" href="/assets/js/13.03f99041.js"><link rel="prefetch" href="/assets/js/14.2f93abcd.js"><link rel="prefetch" href="/assets/js/15.88cc0d50.js"><link rel="prefetch" href="/assets/js/16.d4728eb3.js"><link rel="prefetch" href="/assets/js/17.a7b57260.js"><link rel="prefetch" href="/assets/js/18.a217879c.js"><link rel="prefetch" href="/assets/js/19.118f3da5.js"><link rel="prefetch" href="/assets/js/21.f648c0ea.js"><link rel="prefetch" href="/assets/js/22.5954663e.js"><link rel="prefetch" href="/assets/js/23.b46e9fca.js"><link rel="prefetch" href="/assets/js/24.54967152.js"><link rel="prefetch" href="/assets/js/4.98c29449.js"><link rel="prefetch" href="/assets/js/5.15ec1ba7.js"><link rel="prefetch" href="/assets/js/6.1d64d768.js"><link rel="prefetch" href="/assets/js/7.ef1f0da5.js"><link rel="prefetch" href="/assets/js/8.cc0f0ee5.js"><link rel="prefetch" href="/assets/js/9.8274e3d8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.290fa8e4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">[WIP] 까막's TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/about/" class="nav-link">
  About
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><div class="title">Tags</div> <div class="tag-list"></div> <div class="tag-search"><form id="search-form"><input id="search-input" value=""></form></div></aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="frontmatter-title"><a href="#frontmatter-title" class="header-anchor">#</a> Longest Increasing Subsequence</h1> <h2 id="longest-increasing-subsequence"><a href="#longest-increasing-subsequence" class="header-anchor">#</a> Longest Increasing Subsequence</h2> <p>주어진 수열의 일부 원소를 주어진 순서 그대로 나열한 것을 부분수열이라고 부릅니다.<br>
예를 들어 수열 <code>[5, 2, 3, 1, 4]</code>가 주어졌을 때, <code>[5, 2, 4]</code>, <code>[2, 3, 4]</code>, <code>[2]</code>는 부분수열이지만 <code>[3, 4, 1]</code>은 순서가 바뀌었기 때문에 부분수열이 아닙니다.</p> <p>이 때 부분수열 중 원소가 오름차순이면서 가장 길이가 긴 것을 <strong>Longest Increasing Subsequence</strong>라고 하며, 보통 <strong>LIS</strong>로 줄여서 부릅니다. 위 수열의 경우 <code>[2, 3, 4]</code>가 유일한 LIS가 되겠네요.</p> <h2 id="naive-approach"><a href="#naive-approach" class="header-anchor">#</a> Naive Approach</h2> <p>단순한 방법으로는 모든 부분수열을 구한 뒤 그 중 원소가 오름차순이면서 가장 길이가 긴 것을 찾을 수 있습니다.<br>
그러려면 수열의 각 원소를 포함하거나 포함하지 않는 경우를 고려해야 하므로, 수열의 길이가 N이면 O(2<sup>N</sup>)겠네요.<br>
보기만해도 소름이 돋는 시간 복잡도니까 다른 방법을 찾아보도록 합시다.</p> <h2 id="how-it-works"><a href="#how-it-works" class="header-anchor">#</a> How It Works</h2> <p>오름차순이라 함은 왼쪽에서 오른쪽으로 갈수록 숫자가 커지는 것이기 때문에, 수열을 왼쪽부터 순회하면서 각 단계에 대해 그때까지의 LIS에 대한 정보를 잘만 유지하면 답을 찾아낼 수 있지 않을까 짐작할 수 있습니다.<br>
예컨대 <code>[5, 2, 3, 1, 4]</code>를 왼쪽부터 순회하다가 마지막 <code>4</code>에 이르렀을 때, 그때까지의 LIS가 <code>[2, 3]</code>임을 어케어케 잘 알고있으면 이제 <code>[2, 3, 4]</code>가 LIS가 되는 것을 알 수 있다는 뜻입니다.</p> <blockquote><p>A (길이 N): 주어진 배열<br>
lis (길이 N): LIS 후보들을 담는 배열?</p></blockquote> <p>lis는 위에서 말한 <em>그때까지의 LIS</em> 정보를 담는 데에 사용합니다. 역할이 다소 모호하게 써있는데, 그 이유는 아래에서 설명드릴 예정입니다.</p> <p>lis의 모든 원소를 -1로 초기화 한 후 A를 순회합니다.<br>
각 원소 A[i]를 방문할 때 마다, lis를 왼쪽부터 확인하여 <U>A[i]보다 큰 값이나 -1이 나오면 이를 A[i]로 대체합니다.</U></p> <p><code>[5, 2, 3, 1, 4]</code>을 A로 하여 위 알고리즘을 돌려보겠습니다.</p> <table><thead><tr><th></th> <th></th></tr></thead> <tbody><tr><td>A</td> <td><strong>5</strong> 2 3 1 4</td></tr> <tr><td>lis</td> <td><strong>5</strong> -1 -1 -1 -1</td></tr></tbody></table> <table><thead><tr><th></th> <th></th></tr></thead> <tbody><tr><td>A</td> <td>5 <strong>2</strong> 3 1 4</td></tr> <tr><td>lis</td> <td><strong>2</strong> -1 -1 -1 -1</td></tr></tbody></table> <p>이렇게 기존에 lis에 있던 -1이 아닌 값을 더 작은 값으로 대체하는 이유는<br>
LIS 후보의 앞쪽에 최대한 작은 값이 있어야 LIS를 형성하기에 유리하기 때문입니다.<br>
방금 단계에서 5를 그대로 두면 더이상 어떤 원소와도 오름차순으로 연결될 수 없지만, 2의 경우 연결 가능한 원소가 많죠.</p> <table><thead><tr><th></th> <th></th></tr></thead> <tbody><tr><td>A</td> <td>5 2 <strong>3</strong> 1 4</td></tr> <tr><td>lis</td> <td>2 <strong>3</strong> -1 -1 -1</td></tr></tbody></table> <table><thead><tr><th></th> <th></th></tr></thead> <tbody><tr><td>A</td> <td>5 2 3 <strong>1</strong> 4</td></tr> <tr><td>lis</td> <td><strong>1</strong> 3 -1 -1 -1</td></tr></tbody></table> <table><thead><tr><th></th> <th></th></tr></thead> <tbody><tr><td>A</td> <td>5 2 3 1 <strong>4</strong></td></tr> <tr><td>lis</td> <td>1 3 <strong>4</strong> -1 -1</td></tr></tbody></table> <p>알고리즘이 종료되면 lis에는 <code>[1, 3, 4]</code>가 남습니다. 그럼 이게 수열 A의 LIS겠네요.</p> <p>...아쉽지만 <strong>아닙니다!</strong><br>
A에는 <code>[1, 3, 4]</code>가 순서대로 들어있지 않습니다. 그럼 대체 이 알고리즘으로 알아낼 수 있는 것은 무엇일까요?</p> <p>결론부터 말하면, <strong>LIS의 길이</strong>입니다.<br>
아까 배열 lis의 역할을 <em>LIS 후보들을 담는 배열?</em> 이라고 표현했는데,<br>
정확히는 <strong>lis[j]가 -1이 아닐 때, 길이가 j이고 마지막 원소가 lis[j]인 증가하는 부분수열이 존재함</strong>을 나타내는 배열입니다.</p> <p>즉, 위에서 구한 <code>[1, 3, 4]</code>는 1로 끝나는 길이 1의 부분수열, 3으로 끝나는 길이 2의 부분수열, 4로 끝나는 길이 3의 부분수열이 존재함을 뜻합니다. 그러므로, 아직 뭔지는 몰라도 LIS의 길이는 3임이 보장됩니다.</p> <p>여기서 약간의 장치를 추가하면 LIS가 무엇인지도 찾을 수 있습니다.</p> <blockquote><p>parent (길이 N): 어떤 원소가 lis에 기록될 때, 그 원소 앞에 위치한 원소에 대한 정보를 나타내는 배열</p></blockquote> <p>A[i]를 lis에 기록할 때, 어떤 경우든 lis에서 A[i] 바로 앞에 위치하는 수는 어떤 증가하는 부분수열에서 A[i] 앞에 오는 수가 됩니다. 왜냐하면 lis[j]는 현재 시점에서 길이가 j이고 마지막 원소가 lis[j]인 증가하는 부분수열이 존재함을 나타내기 때문입니다.<br>
따라서 lis[j+1]에 A[i]를 기록하면, 이는 lis[j] &lt; A[i]을 뜻하므로 A[i]을 포함하는 증가하는 부분수열에는 A[i] 바로 앞에 lis[j]가 위치할 수 있습니다.<br>
이를 이용하여 lis에 기록할 때 parent를 함께 갱신하는 방식으로 parent를 완성할 수 있고, parent를 활용하여 lis에 저장된 -1이 아닌 수 중 가장 오른쪽에 있는 숫자부터 시작해서 LIS를 역추적할 수 있습니다.</p> <p>구현 방법은 여러가지가 있을 텐데, 저는 lis와 parent에 원소값 대신 인덱스를 저장하고, lis[j+1]에 i를 기록하면 parent[i]에는 lis[j]를 저장한 후 알고리즘이 종료되면 인덱스를 이용해 LIS를 구하는 방식을 사용합니다.</p> <h2 id="time-complexity"><a href="#time-complexity" class="header-anchor">#</a> Time Complexity</h2> <p>A를 순회하면서(O(N)) 각 방문마다 lis를 순회하므로(O(N)) 총 시간 복잡도는 O(N<sup>2</sup>)입니다. 처음보다 훨씬 낫군요.</p> <p>그런데 시간 복잡도를 한번 더 개선할 수 있습니다.<br>
잘 생각해보면, lis에 저장되는 수는 -1을 제외하면 항상 오름차순임을 알 수 있습니다.</p> <ul><li>-1을 A[i]로 대체한 경우, 그 앞에 있는 수는 모두 A[i]보다 작음</li> <li>-1이 아닌 수 lis[j]를 A[i]로 대체한 경우, lis[j] &lt; A[i]이고 lis[j+1] == -1이거나 A[i] &lt; lis[j+1] 이므로 오름차순 유지</li></ul> <p>그러므로, A[i]이 들어갈 위치를 이분 탐색으로 찾아낼 수 있습니다. 따라서, 각 방문마다 수행하는 lis 탐색은 O(N)이 아닌 O(logN)으로 줄어듭니다.<br>
결국 개선된 시간 복잡도는 O(NlogN)입니다.</p> <p>parent 배열이 추가되어도 parent 갱신은 A의 각 원소를 방문할 때마다 1번까지 일어날 수 있으므로 O(N)이 추가되는 것이기 때문에 시간 복잡도에는 영향이 없습니다.</p> <h2 id="related-problems"><a href="#related-problems" class="header-anchor">#</a> Related Problems</h2> <p><a href="https://www.acmicpc.net/problem/12015" target="_blank" rel="noopener noreferrer">[BOJ 12015] 가장 긴 증가하는 부분 수열 2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br> <a href="https://www.acmicpc.net/problem/1365" target="_blank" rel="noopener noreferrer">[BOJ 1365] 꼬인 전깃줄<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br> <a href="https://www.acmicpc.net/problem/14003" target="_blank" rel="noopener noreferrer">[BOJ 14003] 가장 긴 증가하는 부분 수열 5<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br> <a href="https://www.acmicpc.net/problem/11054" target="_blank" rel="noopener noreferrer">[BOJ 11054] 가장 긴 바이토닉 부분 수열<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer>  <div id="disqus_thread"></div></main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e00fcf70.js" defer></script><script src="/assets/js/3.ebd08407.js" defer></script><script src="/assets/js/2.6d211023.js" defer></script><script src="/assets/js/20.6f566e45.js" defer></script>
  </body>
</html>
