(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{419:function(t,e,_){"use strict";_.r(e);var v=_(56),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"frontmatter-title"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#frontmatter-title"}},[t._v("#")]),t._v(" "+t._s(t.$frontmatter.title))]),t._v(" "),_("h2",{attrs:{id:"description"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#description"}},[t._v("#")]),t._v(" Description")]),t._v(" "),_("p",[t._v("0, 1, 그리고 ?로 이루어진 문자열 "),_("code",[t._v("S")]),t._v("가 주어진다. ?는 0 또는 1로 교체할 수 있다."),_("br"),t._v("\n모든 ?을 0 또는 1로 바꾸어서 길이 5 이상의 팰린드롬인 부분 문자열이 존재하지 않는 문자열을 만들 수 있는지 판단하는 프로그램을 작성하여라.")]),t._v(" "),_("h3",{attrs:{id:"input"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#input"}},[t._v("#")]),t._v(" input")]),t._v(" "),_("p",[t._v("첫 번째 줄에 테스트 케이스의 수인 "),_("code",[t._v("T")]),t._v("가 주어지고, 다음 줄 부터 "),_("code",[t._v("T")]),t._v("개의 테스트 케이스가 제시된다.")]),t._v(" "),_("p",[t._v("각 테스트 케이스는 두 줄로 이루어져 있다:"),_("br"),t._v("\n첫 번째 줄에는 문자열 "),_("code",[t._v("S")]),t._v("의 길이 "),_("code",[t._v("N")]),t._v("이 주어진다."),_("br"),t._v("\n두 번째 줄에는 문자열 "),_("code",[t._v("S")]),t._v("가 주어진다.")]),t._v(" "),_("h3",{attrs:{id:"output"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#output"}},[t._v("#")]),t._v(" output")]),t._v(" "),_("p",[t._v("모든 ?을 0 또는 1로 교체하여 길이 5 이상의 팰린드롬인 부분 문자열이 존재하지 않는 문자열을 만들 수 있으면 POSSIBLE,"),_("br"),t._v("\n불가능하면 IMPOSSIBLE을 출력하라.")]),t._v(" "),_("h3",{attrs:{id:"limit"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#limit"}},[t._v("#")]),t._v(" limit")]),t._v(" "),_("p",[t._v("Memory limit: 1 GB\n1 ≤ "),_("code",[t._v("T")]),t._v(" ≤ 100"),_("br"),t._v(" "),_("code",[t._v("S")]),t._v(" 는 0, 1, ?로만 이루어져있다.")]),t._v(" "),_("p",[t._v("Test Set 1")]),t._v(" "),_("ul",[_("li",[t._v("Time limit: 20 seconds.")]),t._v(" "),_("li",[t._v("1 ≤ "),_("code",[t._v("N")]),t._v(" ≤ 15")])]),t._v(" "),_("p",[t._v("Test Set 2")]),t._v(" "),_("ul",[_("li",[t._v("Time limit: 90 seconds.")]),t._v(" "),_("li",[t._v("1 ≤ "),_("code",[t._v("N")]),t._v(" ≤ 5×10"),_("sup",[t._v("4")])])]),t._v(" "),_("h2",{attrs:{id:"note"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#note"}},[t._v("#")]),t._v(" Note")]),t._v(" "),_("p",[_("code",[t._v("N")]),t._v("이 4 이하인 경우에는 답이 항상 IMPOSSIBLE이므로 "),_("code",[t._v("N")]),t._v("이 5 이상인 경우만 고려한다.")]),t._v(" "),_("p",[t._v("단순하게는 "),_("code",[t._v("S")]),t._v("의 모든 ?를 0 또는 1로 대체한 모든 경우의 수를 확인하는 방법이 있다."),_("br"),t._v("\n모든 경우의 수를 생성할 때 "),_("em",[t._v("O(2"),_("sup",[t._v("N")]),t._v(")")]),t._v(" 이고, 각 경우의 수에 대해 길이 5 이상의 팰린드롬인 부분 문자열이 존재하는지 체크하는 과정은 brute force로 "),_("em",[t._v("O(N"),_("sup",[t._v("2")]),t._v(" * N)")]),t._v(", "),_("a",{attrs:{href:"https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm",target:"_blank",rel:"noopener noreferrer"}},[t._v("Manacher's algorithm"),_("OutboundLink")],1),t._v(" 등의 효율적인 알고리즘으로 "),_("em",[t._v("O(N)")]),t._v(" 에 처리할 수 있다."),_("br"),t._v("\n따라서 모든 경우의 수를 확인하는 방법은 "),_("em",[t._v("O(2"),_("sup",[t._v("N")]),t._v(" * N) ~ O(2"),_("sup",[t._v("N")]),t._v(" * N"),_("sup",[t._v("3")]),t._v(")")]),t._v(" 임을 알 수 있다. Test Set 1 의 경우 "),_("code",[t._v("N")]),t._v("이 최대 15에 불과하므로 이 방법으로 충분히 해결 가능하다.")]),t._v(" "),_("p",[t._v("그러나 Test Set 2를 해결하기 위해서는 더 효율적인 방법이 필요하다."),_("br"),t._v("\n우선, 길이 5 이상의 팰린드롬은 내부에 길이가 5 또는 6인 또다른 팰린드롬을 항상 갖는다. 주어진 팰린드롬의 맨앞과 맨뒤 글자를 하나씩 제거할 때 길이가 5 또는 6이 되는 순간이 존재하고, 이때 남아있는 문자열 역시 팰린드롬을 이루어야하므로 이는 자명하다."),_("br"),t._v("\n따라서 길이가 5 이상인 팰린드롬을 포함하지 않는 어떤 문자열 "),_("code",[t._v("S'")]),t._v("가 있을 때, 이 문자열 뒤에 0 또는 1을 붙였을 때도 여전히 유효한 문자열이 되는 지는 "),_("code",[t._v("S'")]),t._v("의 마지막 문자 5개가 결정한다. 즉, 조건을 만족하는 문자열을 생성하는 과정은 다음과 같은 finite state machine으로 나타낼 수 있다."),_("br"),t._v(" "),_("img",{attrs:{src:"/images/2022-kickstart-A-finite-state-machine.png",alt:"Palindrome Finite State Machine"}}),_("br"),t._v("\n예를 들어서, 마지막 5개의 문자가 11101일 때, 0을 붙이면 여전히 유효한 문자열이지만 1을 추가하면 11011이 생성되어 조건을 만족하지 못한다."),_("br"),t._v("\n이 그래프에서 주목할 만한 점은, 좌우측 안쪽에 사이클이 하나씩 존재하고 이 두 사이클은 서로 완전히 분리되어있다. 따라서 이 fsm을 이용해 유효한 문자열을 생성하려면 두 사이클 중 하나를 반복해야한다. 그리고 그래프에서 두 사이클에 진입하기 전과 후에 지날 수 있는 가장 긴 path의 길이는 각각 2이므로, 길이가 임의의 값 "),_("code",[t._v("M")]),t._v("인 유효한 문자열의 갯수는 항상 최대 4 * 12 * 4 = 192개이다. 이는 단순히 경우의 수만으로 간단히 구한 것으로, 위 그래프를 보고 실제 최댓값을 구해보면 36이 된다.")]),t._v(" "),_("p",[t._v("이를 바탕으로, 주어진 문자열 "),_("code",[t._v("S")]),t._v("에서 처음부터 5번째 문자까지를 prefix로 두고 그 prefix에 6번째 문자부터 하나씩 추가해보며 계속해서 유효한 문자열이 만들어지는지 확인한다. ?가 등장하면 0과 1를 모두 시도해본다. 이때 유효하지 않은 문자열이 생성되면 즉시 해당 탐색 영역을 무시하고 되돌아간다."),_("br"),t._v("\n각 길이 별로 유효한 문자열의 수가 최대 36임을 알고 있으므로, 이 방법을 사용하면 O(36*N) 만큼의 시간이 소요되어 linear time에 문제를 해결할 수 있다.")]),t._v(" "),_("h2",{attrs:{id:"link"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#link"}},[t._v("#")]),t._v(" Link")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://codingcompetitions.withgoogle.com/kickstart/round/00000000008cb33e/00000000009e762e",target:"_blank",rel:"noopener noreferrer"}},[t._v("2022 Kick Start Round A - Palindrome Free Strings"),_("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);