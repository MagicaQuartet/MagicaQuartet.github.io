(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{426:function(t,s,a){"use strict";a.r(s);var e=a(56),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("img",{attrs:{src:"/images/javascript-logo.png",alt:"Javascript-logo"}})]),t._v(" "),a("h1",{attrs:{id:"frontmatter-title"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#frontmatter-title"}},[t._v("#")]),t._v(" "+t._s(t.$frontmatter.title))]),t._v(" "),a("h2",{attrs:{id:"연산자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#연산자"}},[t._v("#")]),t._v(" 연산자")]),t._v(" "),a("p",[a("strong",[t._v("연산자(Operator)")]),t._v(" 는 표현식을 대상으로 연산을 수행해 하나의 값을 만드는 기호입니다. 연산의 대상이 되는 표현식은 "),a("strong",[t._v("피연산자(Operand)")]),t._v(" 라고 부릅니다.")]),t._v(" "),a("p",[t._v("저번 글에서 표현식은 평가되어 하나의 값이 되는 코드 조각이라고 했었죠? 피연산자와 연산자가 결합한 코드 조각도 평가되어 하나의 값이 되기 때문에 표현식입니다.")]),t._v(" "),a("p",[t._v("연산자는 필요한 피연산자의 수에 따라 단항 연산자, 이항 연산자, 삼항 연산자로 분류됩니다.")]),t._v(" "),a("p",[t._v("단항 연산자는 하나의 피연산자를 필요로 하며 다음과 같은 형태로 쓰입니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("연산자 피연산자\n피연산자 연산자\n")])])]),a("p",[t._v("이항 연산자는 연산자의 양 옆에 각각 하나씩 피연산자가 배치됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("피연산자 연산자 피연산자\n")])])]),a("p",[t._v("삼항 연산자는 사실 연산자 수에 따른 분류라기 보다는 그냥 연산자 이름이라고 기억하는 편이 더 좋습니다. 왜냐하면 피연산자 3개를 필요로 하는 연산자는 조건 연산자 뿐이고, 일반적으로 조건 연산자는 삼항 연산자라고 불리기 때문입니다. 조건 연산자는 다음과 같은 형태로 사용합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("피연산자 ? 피연산자 : 피연산자\n")])])]),a("p",[t._v("그럼 이제 자바스크립트에서 제공하는 연산자에는 어떤 것이 있는지 알아보도록 하겠습니다. 자주 쓰는 연산자 위주로 설명을 할 예정이니 자세한 정보를 원하시는 분은 "),a("a",{attrs:{href:"https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Expressions_and_Operators",target:"_blank",rel:"noopener noreferrer"}},[t._v("여기"),a("OutboundLink")],1),t._v("를 참고하시기 바랍니다!")]),t._v(" "),a("h2",{attrs:{id:"할당-연산자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#할당-연산자"}},[t._v("#")]),t._v(" 할당 연산자")]),t._v(" "),a("p",[a("strong",[t._v("할당 연산자")]),t._v("는 이항 연산자로, "),a("strong",[t._v("우변 피연산자의 값을 좌변 피연산자에 할당합니다.")])]),t._v(" "),a("p",[t._v("기본적인 할당 연산자는 등호("),a("code",[t._v("=")]),t._v(")이지만, 그 외에 다른 연산자와 등호를 결합한 복합 할당 연산자도 있습니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 기본 할당 연산자 */")]),t._v("\nx "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 덧셈 할당 연산자. x = x + y */")]),t._v("\nx "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-=")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 뺄셈 할당 연산자. x = x - y */")]),t._v("\nx "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*=")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 곱셈 할당 연산자. x = x * y */")]),t._v("\nx "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/=")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 나눗셈 할당 연산자. x = x / y */")]),t._v("\nx "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%=")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 나머지 할당 연산자. x = x % y */")]),t._v("\n")])])]),a("p",[t._v("할당 연산자가 사용된 표현식은 좌변 피연산자(일반적으로는 변수)에 값을 할당하면서 상태 변화를 일으키는 side effect를 가지고 있기는 하지만, 본질적으로는 표현식이기 때문에 평가되어 하나의 값을 반환합니다. 여기서 그 값은 "),a("strong",[t._v("우변 피연산자를 평가한 값")]),t._v("입니다. 참고로 변수에 할당되는 값과 표현식의 값은 다를 수 있으니 혼동하지 않도록 합시다!")]),t._v(" "),a("p",[t._v("단, 복합 할당 연산자를 사용한 표현식의 경우 기본 할당 연산자를 사용한 동등한 표현식에서의 우변 피연산자를 평가한 값을 가집니다. 말이 길어져서 복잡해 보이는데 그냥 이런겁니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("40")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" y "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Result: 42. x = x + y에서 x + y의 값 */")]),t._v("\n")])])]),a("p",[t._v("자바스크립트에서 할당 연산자는 유일하게 오른쪽에서 왼쪽으로 평가가 진행되도록 하는 연산자입니다. 그런 만큼 조금 독특한 부분이 있기 때문에 메커니즘을 짚고 넘어갈 필요가 있습니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\na "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("위 코드는 "),a("em",[t._v("유효한")]),t._v(" 자바스크립트 코드입니다. 할당 연산자 표현식이 어떻게 평가되는지 그 과정을 살펴보도록 합시다.")]),t._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[a("strong",[t._v("할당식은 좌변이 먼저 평가됩니다. 그 뒤에 "),a("code",[t._v("=")]),t._v("를 기준으로 우변이 평가됩니다.")])]),t._v(" "),a("li",[t._v("따라서 먼저 "),a("code",[t._v("a")]),t._v("라는 식별자가 존재하는 지를 평가하고 우변 피연산자인 "),a("code",[t._v("b = c = 1")]),t._v("이 평가됩니다.")]),t._v(" "),a("li",[a("code",[t._v("b = c = 1")]),t._v("는 1번과 마찬가지로 "),a("code",[t._v("b")]),t._v("가 먼저 평가된 뒤, "),a("code",[t._v("c = 1")]),t._v("이 평가됩니다.")]),t._v(" "),a("li",[a("code",[t._v("c = 1")]),t._v("도 같은 방식으로 평가되어, 변수 c에 1을 할당함과 동시에 1을 반환합니다.")]),t._v(" "),a("li",[t._v("따라서 "),a("code",[t._v("b = c = 1")]),t._v("는 "),a("code",[t._v("b = 1")]),t._v("과 같게 되고, 변수 b에 1을 할당함과 동시에 1을 반환합니다.")]),t._v(" "),a("li",[t._v("최종적으로 "),a("code",[t._v("a = b = c = 1")]),t._v("은 "),a("code",[t._v("a = 1")]),t._v("과 같게 되어 변수 a에 1을 할당함과 동시에 1을 반환합니다.")])]),t._v(" "),a("h2",{attrs:{id:"비교-연산자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#비교-연산자"}},[t._v("#")]),t._v(" 비교 연산자")]),t._v(" "),a("p",[a("strong",[t._v("비교 연산자")]),t._v("는 "),a("strong",[t._v("피연산자들을 비교하고 그 결과에 따라 "),a("code",[t._v("Boolean")]),t._v(" 값을 반환합니다.")]),t._v(" 비교 연산자의 종류에는 "),a("code",[t._v("==")]),t._v(", "),a("code",[t._v("!=")]),t._v(", "),a("code",[t._v("===")]),t._v(", "),a("code",[t._v("!==")]),t._v(", "),a("code",[t._v(">")]),t._v(", "),a("code",[t._v(">=")]),t._v(", "),a("code",[t._v("<")]),t._v(", "),a("code",[t._v("<=")]),t._v(" 등이 있습니다. 참고로 "),a("code",[t._v(">=")]),t._v("와 "),a("code",[t._v("=>")]),t._v("는 전혀 다르니 주의하시기 바랍니다! "),a("code",[t._v("=>")]),t._v("는 비교 연산자가 아니고, 자바스크립트의 함수를 공부할 때 만날 수 있는 기호입니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n")])])]),a("p",[t._v("대부분 다른 언어에서도 사용하는 표현이니 크게 낯설지는 않을 것입니다. 그런데 조금 이상한 연산자들이 눈에 띄네요. "),a("code",[t._v("===")]),t._v(", "),a("code",[t._v("!==")]),t._v(" 이 친구들은 어떻게 다르길래 등호가 하나 더 붙어있는 걸까요?")]),t._v(" "),a("p",[t._v("이에 대해 설명하기 위해서는 우선 "),a("em",[t._v("자바스크립트의 타입 변환")]),t._v("에 대해 이해를 해야 합니다. 상당히 중요한 내용이니 나중에 따로 정리할 예정이지만, 연산자를 설명하면서 빠질 수 없는 내용이므로 이 글에서도 조금씩 설명을 하도록 하겠습니다.")]),t._v(" "),a("p",[t._v("자바스크립트에서는 비교 연산자의 두 피연산자가 다른 형태일 경우 비교가 가능하도록 "),a("strong",[t._v("피연산자를 적절한 타입으로 변환합니다.")]),t._v(" 이와 관련해 다음과 같은 유명한 그림이 있습니다.")]),t._v(" "),a("p",[a("img",{attrs:{src:"/images/the-javascript-trinity.jpg",alt:"Javascript-trinity"}})]),t._v(" "),a("p",[t._v("그리고 아래의 동등 비교는 모두 참입니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"42"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("믿지 못하겠다면 당장 F12를 눌러 콘솔에서 직접 확인해보도록 합시다!")]),t._v(" "),a("p",[t._v("이처럼 개발자가 명시하지 않은, 자바스크립트 엔진에 의한 컨텍스트에 따른 타입 변환을 "),a("strong",[t._v("암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)")]),t._v(" 이라고 합니다. 그래서 "),a("em",[t._v("자료형까지 같은 값")]),t._v("인지 알아보기 위해서는 "),a("code",[t._v("==")]),t._v("만으로는 부족했습니다. 그래서 자료형의 일치 여부도 확인하는 "),a("code",[t._v("===")]),t._v(", "),a("code",[t._v("!==")]),t._v("연산자를 사용하게 된 것입니다.")]),t._v(" "),a("h3",{attrs:{id:"동등-연산자-부등-연산자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#동등-연산자-부등-연산자"}},[t._v("#")]),t._v(" 동등 연산자 "),a("code",[t._v("==")]),t._v(", 부등 연산자 "),a("code",[t._v("!=")])]),t._v(" "),a("p",[t._v("아래의 표현식은 모두 "),a("code",[t._v("true")]),t._v("를 반환합니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"42"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("NaN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("NaN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n")])])]),a("ul",[a("li",[t._v("두 피연산자가 각각 "),a("code",[t._v("Number")]),t._v("와 "),a("code",[t._v("String")]),t._v(" 값일 경우, "),a("code",[t._v("String")]),t._v(" 값이 "),a("code",[t._v("Number")]),t._v(" 값으로 변환됩니다.")]),t._v(" "),a("li",[t._v("두 피연산자가 각각 "),a("code",[t._v("Number")]),t._v("와 "),a("code",[t._v("Boolean")]),t._v(" 혹은 "),a("code",[t._v("String")]),t._v("과 "),a("code",[t._v("Boolean")]),t._v(" 값일 경우, "),a("code",[t._v("true")]),t._v("는 1, "),a("code",[t._v("false")]),t._v("는 0으로 변환됩니다.")]),t._v(" "),a("li",[t._v("두 피연산자가 모두 "),a("code",[t._v("Object")]),t._v("일 경우, 두 피연산자가 메모리 상에서 같은 객체를 가리킬 경우 동일한 객체로 간주합니다. 그렇지 않을 경우 속성과 속성값이 같더라도 항상 다른 객체로 간주합니다.")]),t._v(" "),a("li",[a("code",[t._v("null")]),t._v("과 "),a("code",[t._v("undefined")]),t._v("는 서로 동등합니다.")]),t._v(" "),a("li",[a("code",[t._v("NaN")]),t._v("은 자기 자신을 포함하여 어떤 것과도 동등하지 않습니다.")])]),t._v(" "),a("p",[t._v("... 몇 가지만 열거하였는데 벌써 정신이 조금 혼미해집니다. 타입 변환과 관계없는 내용은 기억해 둘 필요가 있지만, 타입 변환 때문에 일어나는 현상은 충분히 "),a("code",[t._v("===")]),t._v(", "),a("code",[t._v("!==")]),t._v(" 연산자를 통해 피해갈 수 있습니다. 가끔은 암묵적 타입 변환이 편리하다고 느낄 때도 있겠지만 예측하기 어려운 부작용을 일으키기 쉽기 때문에 가급적이면 사용하지 않는 것이 좋습니다.")]),t._v(" "),a("h3",{attrs:{id:"일치-연산자-불일치-연산자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#일치-연산자-불일치-연산자"}},[t._v("#")]),t._v(" 일치 연산자 "),a("code",[t._v("===")]),t._v(", 불일치 연산자 "),a("code",[t._v("!==")])]),t._v(" "),a("p",[t._v("일치 연산자와 불일치 연산자는 두 피연산자의 자료형이 달라도 암묵적 타입 변환을 하지 않습니다. 즉, "),a("strong",[t._v("타입 변환 없이도 같은 값(strict equal)")]),t._v(" 인지를 확인합니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* false */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* false */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* false */")]),t._v("\n")])])]),a("p",[t._v("이제 "),a("em",[t._v("대충 같은 값")]),t._v("이 아니라 "),a("em",[t._v("진짜로 같은 값")]),t._v("인지 확실하게 알아볼 수 있습니다! 이처럼 암묵적 타입 변환에 따른 부작용이 없기 때문에 동등/부등 연산자 대신 일치/불일치 연산자를 사용할 것을 강력히 권장합니다.")]),t._v(" "),a("h2",{attrs:{id:"산술-연산자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#산술-연산자"}},[t._v("#")]),t._v(" 산술 연산자")]),t._v(" "),a("p",[a("strong",[t._v("산술 연산자")]),t._v("는 "),a("strong",[t._v("숫자 값을 피연산자로 갖고, 하나의 숫자 값을 반환합니다.")]),t._v(" 산술 연산자에는 기본적인 산술 연산자인 덧셈 "),a("code",[t._v("+")]),t._v(", 뺄셈 "),a("code",[t._v("-")]),t._v(", 곱셈 "),a("code",[t._v("*")]),t._v(", 나눗셈 "),a("code",[t._v("/")]),t._v("과 그 외에 나머지 "),a("code",[t._v("%")]),t._v(", 증가 "),a("code",[t._v("++")]),t._v(", 감소 "),a("code",[t._v("--")]),t._v(" 등이 있습니다.")]),t._v(" "),a("p",[t._v("각 연산자에 대한 설명을 간략하게 하고 넘어가도록 하겠습니다.")]),t._v(" "),a("h3",{attrs:{id:"사칙연산-연산자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#사칙연산-연산자"}},[t._v("#")]),t._v(" 사칙연산 연산자 "),a("code",[t._v("+")]),t._v(", "),a("code",[t._v("-")]),t._v(", "),a("code",[t._v("*")]),t._v(", "),a("code",[t._v("/")])]),t._v(" "),a("p",[t._v("주어진 두 "),a("code",[t._v("Number")]),t._v(" 및 "),a("code",[t._v("Boolean")]),t._v(" 피연산자의 사칙연산 결과 값을 반환합니다. "),a("code",[t._v("true")]),t._v("는 1, "),a("code",[t._v("false")]),t._v("는 0으로 간주됩니다. 만약 피연산자 중에 "),a("code",[t._v("String")]),t._v(" 값이 있다면 "),a("code",[t._v("+")]),t._v("를 제외한 연산자는 "),a("code",[t._v("NaN")]),t._v("을 반환합니다. "),a("code",[t._v("+")]),t._v("의 경우 두 피연산자를 연결한 "),a("code",[t._v("String")]),t._v(" 값이 반환되며, 이처럼 "),a("code",[t._v("+")]),t._v("가 문자열을 연결하는 역할을 할 경우 이를 "),a("em",[t._v("문자열 연산자")]),t._v("라고도 부릅니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 3 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* -1 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 12 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 2.5 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"string"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/* "5string" */')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"string"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/* "stringfalse" */')]),t._v("\n")])])]),a("h3",{attrs:{id:"나머지-연산자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#나머지-연산자"}},[t._v("#")]),t._v(" 나머지 연산자 "),a("code",[t._v("%")])]),t._v(" "),a("p",[t._v("좌변 피연산자를 우변 피연산자로 나누었을 때의 나머지를 반환하며 결과 값의 부호는 항상 좌변 피연산자의 부호와 동일합니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 2 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 2 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* -2 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* -2 */")]),t._v("\n")])])]),a("h3",{attrs:{id:"거듭제곱-연산자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#거듭제곱-연산자"}},[t._v("#")]),t._v(" 거듭제곱 연산자 "),a("code",[t._v("**")])]),t._v(" "),a("blockquote",[a("p",[t._v("거듭제곱 연산자는 ES7(ES2016)에서 추가되었습니다.")])]),t._v(" "),a("p",[t._v("좌변 피연산자를 밑으로, 우변 피연산자를 지수로 한 값을 반환합니다. 이 때 좌변 피연산자에는 "),a("code",[t._v("+")]),t._v(", "),a("code",[t._v("-")]),t._v("을 비롯한 어떤 단항 연산자도 배치할 수 없습니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("**")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 16 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("**")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 0.0625 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("**")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Invalid expression */")]),t._v("\n")])])]),a("h3",{attrs:{id:"증감-연산자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#증감-연산자"}},[t._v("#")]),t._v(" 증감 연산자 "),a("code",[t._v("++")]),t._v(", "),a("code",[t._v("--")])]),t._v(" "),a("p",[t._v("증가 연산자 "),a("code",[t._v("++")]),t._v("와 감소 연산자 "),a("code",[t._v("--")]),t._v("는 단항 연산자로, 피연산자를 1씩 증가/감소시킵니다. 반환하는 값은 연산자의 위치에 따라 다릅니다.")]),t._v(" "),a("ul",[a("li",[t._v("연산자가 피연산자 앞에 있을 경우, 증가/감소하기 전의 값을 반환합니다.")]),t._v(" "),a("li",[t._v("연산자가 피연산자 뒤에 있을 경우, 증가/감소한 후의 값을 반환합니다.")])]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" incrementPrefix "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("incrementPostfix "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" decrementPrefix "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("decrementPostfix "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("incrementPrefix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Result is 6, incrementPrefix is 6 */")]),t._v("\nincrementPostfix"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Result is 5, incrementPostfix is 6 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("decrementPrefix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Result is 4, decrementPrefix is 4 */")]),t._v("\ndecrementPostfix"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Result is 5, decrementPrefix is 4 */")]),t._v("\n")])])]),a("h2",{attrs:{id:"논리-연산자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#논리-연산자"}},[t._v("#")]),t._v(" 논리 연산자")]),t._v(" "),a("p",[t._v("자바스크립트의 논리 연산자로는 논리 AND "),a("code",[t._v("&&")]),t._v(", 논리 OR "),a("code",[t._v("||")]),t._v(", 논리 NOT "),a("code",[t._v("!")]),t._v("이 있습니다. 다른 많은 언어에서는 "),a("code",[t._v("&&")]),t._v("는 두 피연산자가 모두 참인지, "),a("code",[t._v("||")]),t._v("는 두 피연산자 중 하나 이상이 참인지, 그리고 "),a("code",[t._v("!")]),t._v("은 주어진 피연산자가 참일 경우 거짓, 거짓일 경우 참을 반환하는 연산자입니다. 자바스크립트에서도 크게 다르지는 않겠죠? 그러나 이게 끝이 아니고, 꼭 알아두고 넘어가야 하는 중요한 내용이 숨어있습니다.")]),t._v(" "),a("p",[t._v("일반적으로 논리 연산자라고 하면 "),a("code",[t._v("Boolean")]),t._v(" 피연산자를 받아서 "),a("code",[t._v("Boolean")]),t._v(" 값을 반환하는 연산자라고 생각하기 쉽습니다. 그러나 자바스크립트의 논리 연산자는 큰 틀에서는 비슷하지만, 동작 과정에서 조금 차이가 있습니다. 부정 연산자 "),a("code",[t._v("!")]),t._v("를 제외하면, 피연산자가 "),a("code",[t._v("Boolean")]),t._v(" 값이 아닐 수도 있고 반환값이 "),a("code",[t._v("Boolean")]),t._v(" 값이 아닐 수도 있습니다.")]),t._v(" "),a("h3",{attrs:{id:"truthy-값-falsy-값"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#truthy-값-falsy-값"}},[t._v("#")]),t._v(" Truthy 값, Falsy 값")]),t._v(" "),a("p",[t._v("자바스크립트에서는 "),a("strong",[t._v("명시적인 "),a("code",[t._v("Boolean")]),t._v(" 값이 아니어도 문맥에 따라 "),a("code",[t._v("Boolean")]),t._v(" 값으로 평가될 수 있습니다.")]),t._v(" 조건문 및 반복문의 조건, 그리고 "),a("strong",[t._v("논리 연산자의 피연산자")]),t._v("가 이러한 문맥에 해당합니다. "),a("code",[t._v("true")]),t._v("로 평가되는 값은 "),a("strong",[t._v("truthy")]),t._v(" 값, "),a("code",[t._v("false")]),t._v("로 평가되는 값은 "),a("strong",[t._v("falsy")]),t._v(" 값이라고 부릅니다.")]),t._v(" "),a("p",[t._v("명시적으로 falsy 값으로 정의되지 않은 값은 모두 truthy 값입니다. 자바스크립트의 falsy 값은 다음과 같습니다.")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("false")])]),t._v(" "),a("li",[a("code",[t._v("null")])]),t._v(" "),a("li",[a("code",[t._v("undefined")])]),t._v(" "),a("li",[a("code",[t._v("NaN")])]),t._v(" "),a("li",[a("code",[t._v("''")])]),t._v(" "),a("li",[t._v("0")])]),t._v(" "),a("p",[t._v("참고로 빈 "),a("code",[t._v("String")]),t._v(" 값과는 달리 빈 배열이나 "),a("code",[t._v("Object")]),t._v("는 falsy가 아닙니다.")]),t._v(" "),a("p",[t._v("이처럼 모든 값은 문맥에 따라 "),a("code",[t._v("Boolean")]),t._v("으로 평가될 수 있기 때문에 논리 연산자의 피연산자에 "),a("code",[t._v("Boolean")]),t._v("이 아닌 값이 올 수 있는 것입니다.")]),t._v(" "),a("h3",{attrs:{id:"단축-평가-short-circuit-evaluation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#단축-평가-short-circuit-evaluation"}},[t._v("#")]),t._v(" 단축 평가 (Short-Circuit Evaluation)")]),t._v(" "),a("p",[t._v("그럼 피연산자는 그렇다치고, 반환값은 "),a("code",[t._v("Boolean")]),t._v(" 값이 되어야할 것 같지 않나요? 아무튼 피연산자들을 참 같은 값, 거짓 같은 값으로 바꾸어서 논리 연산을 하니까요.")]),t._v(" "),a("p",[t._v("이에 대해 설명하기에 앞서 논리 연산자 표현식의 평가가 어떻게 진행되는 지를 살펴봅시다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Cat"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Dog"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Cat"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Dog"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[a("code",[t._v("||")]),t._v("연산자의 경우 두 연산자 중 truthy 값이 하나라도 있으면 참을 나타내게 됩니다. 그렇다면 좌변 피연산자가 truthy 값이라면 우변 피연산자는 볼 필요도 없이 그 표현식은 참이 됩니다. 따라서 이러한 경우 우변 피연산자를 평가하지 않은 채 그대로 표현식의 평가가 종료됩니다.")]),t._v(" "),a("p",[t._v("반면 "),a("code",[t._v("&&")]),t._v(" 연산자는 두 연산자가 모두 truthy 값이여야 참이 됩니다. 따라서 좌변 피연산자가 falsy 값이라면 우변 피연산자와 상관없이 표현식의 평가 결과는 거짓이 될 것이고, 우변 피연산자를 평가하지 않고 평가를 끝냅니다.")]),t._v(" "),a("p",[t._v("이처럼 "),a("strong",[t._v("논리 연산 결과가 결정되는 시점에 표현식의 평가를 끝내는 방식")]),t._v("을 "),a("strong",[t._v("단축 평가 (Short-Circuit Evaluation)")]),t._v(" 라고 합니다. 사실 단축 평가 자체는 다른 언어의 논리 연산에서도 사용되는 방식입니다. 그런데 자바스크립트에서 특이한 점은, "),a("strong",[a("code",[t._v("&&")]),t._v("연산자와 "),a("code",[t._v("||")]),t._v(" 연산자가 반환하는 값은 논리 연산 결과를 결정한 피연산자의 값")]),t._v("이라는 점입니다. 즉, 위 예시의 결과값은 다음과 같습니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Cat"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Dog"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/* "Dog" */')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Cat"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Dog"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/* "Cat" */')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* null */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 42 */")]),t._v("\n")])])]),a("p",[t._v("그런데 반환하는 값이 "),a("code",[t._v("Boolean")]),t._v("이 아니면, 어떻게 조건문이나 반복문에서 이러한 표현식을 쓸 수 있을까요? 조건이 "),a("code",[t._v("true")]),t._v("거나 "),a("code",[t._v("false")]),t._v("여야 블록 내부의 코드를 실행할지 말지를 판단할텐데요.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Cat"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Dog"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("답은 간단합니다. 조건이 위치하는 곳도 역시 "),a("code",[t._v("Boolean")]),t._v("으로의 변환이 일어날 수 있는 컨텍스트인 것입니다. "),a("code",[t._v('"Cat" && "Dog"')]),t._v("의 값은 "),a("code",[t._v('"Dog"')]),t._v("이고, 길이가 0 이상인 "),a("code",[t._v("String")]),t._v(" 값은 truthy 값이므로 블록 내부의 코드를 실행하게 됩니다.")]),t._v(" "),a("p",[t._v("참고로 이러한 성질을 이용하여 주어진 변수나 함수 인자가 유효한 값인지 (주로 "),a("code",[t._v("null")]),t._v("이나 "),a("code",[t._v("undefined")]),t._v("가 아닌지) 확인하는 패턴이 사용되니 한번쯤 봐두면 좋습니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" elem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("elem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Error */")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("elem "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" elem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* undefined */")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getStringLength")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("str")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" _str "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" str "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" _str"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("그런데 단축 평가 설명에서 논리 NOT "),a("code",[t._v("!")]),t._v(" 연산자 얘기는 쏙 빠져있군요. "),a("code",[t._v("&&")]),t._v(", "),a("code",[t._v("||")]),t._v("와는 달리 "),a("code",[t._v("!")]),t._v(" 연산자는 반환값이 항상 "),a("code",[t._v("Boolean")]),t._v(" 값입니다. 피연산자가 truthy 값이면 "),a("code",[t._v("false")]),t._v(", falsy 값이면 "),a("code",[t._v("true")]),t._v("를 반환합니다.")]),t._v(" "),a("p",[t._v("정리하면, 자바스크립트의 논리 연산자가 하는 역할은 다음과 같습니다.")]),t._v(" "),a("h3",{attrs:{id:"논리-and"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#논리-and"}},[t._v("#")]),t._v(" 논리 AND "),a("code",[t._v("&&")])]),t._v(" "),a("p",[t._v("이항 연산자로, 좌변 피연산자가 falsy 값인 경우 좌변 피연산자의 값을 반환하고 truthy 값인 경우 우변 피연산자의 값을 반환합니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* null */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* null */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Cat"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Dog"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/* "Dog" */')]),t._v("\n")])])]),a("h3",{attrs:{id:"논리-or"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#논리-or"}},[t._v("#")]),t._v(" 논리 OR "),a("code",[t._v("||")])]),t._v(" "),a("p",[t._v("이항 연산자로, 좌변 피연산자가 truthy 값인 경우 좌변 피연산자의 값을 반환하고 falsy 값인 경우 우변 피연산자의 값을 반환합니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* true */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* false */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Cat"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Dog"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/* "Cat" */')]),t._v("\n")])])]),a("h3",{attrs:{id:"논리-not"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#논리-not"}},[t._v("#")]),t._v(" 논리 NOT "),a("code",[t._v("!")])]),t._v(" "),a("p",[t._v("단항 연산자로, 피연산자가 truthy 값인 경우 "),a("code",[t._v("false")]),t._v("를 반환하고 falsy 값인 경우 "),a("code",[t._v("true")]),t._v("를 반환합니다.")]),t._v(" "),a("h2",{attrs:{id:"조건-연산자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#조건-연산자"}},[t._v("#")]),t._v(" 조건 연산자")]),t._v(" "),a("p",[t._v("조건 연산자는 앞서 언급한 것처럼 3개의 피연산자를 필요로 하는 유일한 연산자이기 때문에 삼항 연산자로도 불립니다.")]),t._v(" "),a("p",[t._v("조건 연산자 표현식은 "),a("code",[t._v("condition ? expr1 : expr2")]),t._v("의 형태를 가집니다. 평가 결과는 "),a("code",[t._v("condition")]),t._v("이 truthy 값이면 "),a("code",[t._v("expr1")]),t._v("의 값, falsy 값이면 "),a("code",[t._v("expr2")]),t._v("의 값이 됩니다.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" isAnswer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Answer to everything"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Nope"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("isAnswer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/* "Answer to everything" */')]),t._v("\n")])])]),a("p",[a("em",[t._v("주어진 조건을 만족하면 이 값, 아니면 저 값")]),t._v("이라는 로직만을 구현하기 위해 "),a("code",[t._v("if-else")]),t._v(" 블록을 만드는 건 조금 군더더기일 수 있겠죠? 그런 상황에서 조건 연산자를 유용하게 사용할 수 있습니다.")]),t._v(" "),a("h2",{attrs:{id:"reference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[t._v("#")]),t._v(" Reference")]),t._v(" "),a("ul",[a("li",[t._v("표현식과 연산자 - Javascript | MDN "),a("a",{attrs:{href:"https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Expressions_and_Operators",target:"_blank",rel:"noopener noreferrer"}},[t._v("Link"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("Operator | PoiemaWeb "),a("a",{attrs:{href:"https://poiemaweb.com/js-operator",target:"_blank",rel:"noopener noreferrer"}},[t._v("Link"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("Type coercion | PoiemaWeb "),a("a",{attrs:{href:"https://poiemaweb.com/js-type-coercion",target:"_blank",rel:"noopener noreferrer"}},[t._v("Link"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("자바스크립트의 할당연산자 고찰 | BSIDESOFT co. "),a("a",{attrs:{href:"https://www.bsidesoft.com/?p=1975",target:"_blank",rel:"noopener noreferrer"}},[t._v("Link"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=r.exports}}]);